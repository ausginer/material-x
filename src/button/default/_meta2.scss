@use '../../core/defaults/motion-effects';
@use '../../core/processor/set';
@use '../../core/processor/groups';
@use '../../core/tokens/md-comp-button';
@use '../../core/utils/map';
@use '../shape/meta' as *;
@use '../vars';

$-groups: groups.from(md-comp-button.$map, $group-callback);

/// A map of specific variables that are not explicitly set by the M3 spec, but
/// are necessary for the button to function correctly. Usually, all these
/// variables are private.
///
/// @type {Map<String, *>}
$-special-vars: map.merge(
  $round-tokens,
  (
    'state-layer-opacity': map.get($-groups, 'pressed', 'state-layer-opacity'),
    'state-layer-color': map.get($-groups, 'pressed', 'state-layer-color'),
    'padding-block': calc(
        (
            var(--_container-height) - max(
                var(--_icon-size),
                var(--_label-text-line-height)
              )
          ) /
          2
      ),
    'press-damping': map.get(
        $-groups,
        'pressed',
        'container-corner-size-motion-spring-damping'
      ),
    'press-stiffness': map.get(
        $-groups,
        'pressed',
        'container-corner-size-motion-spring-stiffness'
      ),
    'press-duration': motion-effects.$expressive-fast-effects-duration,
    'ripple-color': var(--_state-layer-color),
    'ripple-easing': motion-effects.$expressive-fast-effects,
    'ripple-opacity': var(--_state-layer-opacity),
    'press-factor': 0,
  )
);

/// Converts a group into a {@link TokenSet}.
///
/// @param {String} $key - The name of the group.
/// @param {Map} $group - The map of tokens in the group.
/// @param {Map} $map - The full map of tokens.
/// @param {Map} $special-vars - A map of custom variables to merge into
/// the default set.
@function -groups-to-sets($key, $group, $map, $special-vars) {
  // If the group is `default`, we don't have a base to extend from, so we just
  // merge the custom variables in.
  @if ($key == 'default') {
    $group: map.merge($group, $special-vars);
    @return set.create($key, $group);
  }

  // If the group is `selected` or `unselected`, it is a complex group that
  // contains multiple states. In that case, we convert each state from this
  // group to a set separately.
  @if ($key == 'unselected' or $key == 'selected') {
    @return map.map($group, meta.get-function('-groups-to-sets'));
  }

  $default: map.get($map, 'default');

  // For all other groups, we extend from the `default` set.
  @return set.create($key, set.extend($group, $default));
}

/// A map of all token sets for buttons. Variables are not yet processed (no
/// public/private distinction).
///
/// This map is necessary for further references for other types of buttons.
///
/// @type {Map<String, TokenSet>}
$sets: map.map(
  $-groups,
  meta.get-function('-groups-to-sets'),
  $-groups,
  $-special-vars
);

/// A wrapper around {@link -process-vars} to provide custom `$prefix`.
///
/// @param {String} $key - The name of the variable.
/// @param {*} $value - The value of the variable.
/// @param {Map} $map - The full map of tokens.
/// @param {Function} $to-public-var-callback - A function to convert a public
/// variable to a CSS variable reference.
/// @param {String} $prefix - The prefix to use for the public CSS variable.
/// @returns {VarTuple|Map|Null} - A {@link VarTuple}, a map of {@link VarTuple}
/// or `null` to skip the variable.
@function -process-vars($key, $value, $map, $to-public-var-callback) {
  @return meta.call(
    $process-vars,
    $key,
    $value,
    $map,
    $to-public-var-callback,
    'md-button'
  );
}

/// Prepares a set by processing its variables and distinguishing public and
/// private ones.
///
/// @param {String} $key - The name of the set.
/// @param {TokenSet|Map<String, TokenSet>} $set - The token set or a nested map
/// of token sets.
/// @param {Map} $-void - Unused parameter to match the signature of
/// {@link map.map}.
/// @returns {TokenSet|Map<String, TokenSet>} - The processed token set or a map
/// of processed token sets.
@function -prepare-set($key, $set, $-void...) {
  // The `selected` and `unselected` sets are complex and contain multiple
  // states. We need to process each state of them separately.
  @if ($key == 'selected' or $key == 'unselected') {
    @return map.map($set, meta.get-function('-prepare-set'));
  }

  @return set.vars($set, meta.get-function('-process-vars'));
}

$-prepared-sets: map.map($sets, meta.get-function('-prepare-set'));

$default: map.get($-prepared-sets, 'default');
$hovered: map.get($-prepared-sets, 'hovered');
$focused: map.get($-prepared-sets, 'focused');
$pressed: map.get($-prepared-sets, 'pressed');
$disabled: map.get($-prepared-sets, 'disabled');

$unselected: map.get($-prepared-sets, 'unselected');
$selected: map.get($-prepared-sets, 'selected');
